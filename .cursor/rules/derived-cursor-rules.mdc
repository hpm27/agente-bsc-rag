---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## HEADERS

## TECH STACK

### Test Methodology (Validado Out/2025 - ROI: 32-60 min economizados por implementaÃ§Ã£o)

**ANTES de escrever QUALQUER teste (unitÃ¡rio ou E2E), aplicar [[memory:9969868]] - CHECKLIST OBRIGATÃ“RIO de 12 pontos**:

**PONTOS 1-8: Testes UnitÃ¡rios** (validado FASE 2.5)

1. **Ler assinatura completa**: `grep "def method_name" src/file.py -A 10` (NUNCA assumir)
2. **Verificar tipo retorno**: Objeto Pydantic ou built-in? Campos obrigatÃ³rios?
3. **Contar parÃ¢metros**: Quantos params (nÃ£o contar `self`)?
4. **ValidaÃ§Ãµes prÃ©-flight**: ValidaÃ§Ãµes no cÃ³digo + Pydantic (min_length, Literal, validators)
5. **Entender decorators**: @retry com `reraise=True` relanÃ§a exceÃ§Ã£o original (NÃƒO RetryError)
6. **Fixtures Pydantic**: NUNCA passar `None` para `default_factory`. Incluir campos obrigatÃ³rios.
7. **Dados vÃ¡lidos em mocks**: Usar MARGEM DE SEGURANÃ‡A (ex: min_length=20 â†’ usar 50+ chars)
8. **Verificar mÃ©todo correto**: Confirmar nome exato via grep (ex: `invoke()` nÃ£o `process_query()`)

**PONTOS 9-12: E2E Workflow Tests** (validado FASE 2.6) - Ver seÃ§Ã£o "E2E Workflow Tests" below for details

**Debugging pytest (Validado [[memory:9969628]] e [[memory:10012853]])**:
*   **SEMPRE** usar `--tb=long` (traceback completo, NUNCA --tb=short)
*   **NUNCA** usar filtros (`Select-Object`, `Select-String`) - oculta informaÃ§Ã£o crÃ­tica
*   Comando correto: `pytest tests/test_file.py -v --tb=long 2>&1`

**pytest em paralelo** (performance):
*   `-n <num_workers>`: Workers paralelos
*   `-v`: Verbose output
*   `--tb=long`: Traceback completo
*   `--dist=loadscope`: Distribui por fixture scope (mais seguro)
*   `--dist=loadfile`: Distribui por arquivo (fixtures function-scoped)

**LiÃ§Ãµes Detalhadas**:
- `docs/lessons/lesson-test-debugging-methodology-2025-10-15.md` (FASE 2.4, 5 erros)
- `docs/lessons/lesson-diagnostic-agent-test-methodology-2025-10-16.md` (FASE 2.5, 7 erros, 1.100+ linhas)
- `docs/lessons/lesson-onboarding-state-e2e-tests-2025-10-16.md` (FASE 2.6, 4 problemas E2E, 11.900+ linhas)

**ROI Comprovado**: Aplicar checklist ANTES economiza 38 minutos de debugging por implementaÃ§Ã£o (validado FASE 2.5 unitÃ¡rio, FASE 2.6 E2E).

#### E2E Workflow Tests (Validado FASE 2.6 - Out/2025)

**Context**: Testes E2E de workflows LangGraph multi-turn stateless requerem 4 consideraÃ§Ãµes adicionais ao checklist base.

**4 Pontos Adicionais (Checklist expandido: 8 â†’ 12 pontos)**:

**9. Verificar property/mÃ©todo existe**:
*   **SEMPRE** usar `grep "@property\|def method_name" src/file.py` antes de usar em cÃ³digo
*   **Exemplo validado (2025-10-16)**: Assumiu `client_profile_agent` property existia â†’ `AttributeError`
*   **PrevenÃ§Ã£o**: 
    ```bash
    grep "@property" src/graph/workflow.py | grep "client_profile_agent"
    # Se nÃ£o retornar nada, property nÃ£o existe - criar ou usar alternativa
    ```
*   **ROI**: 5-8 min economizados

**10. Considerar persistÃªncia de state**:
*   **SEMPRE** perguntar: "Como state persiste entre mÃºltiplos `run()` calls?"
*   **Exemplo validado (2025-10-16)**: Workflow stateless, `onboarding_progress` perdido entre calls
*   **SoluÃ§Ã£o padrÃ£o**: In-memory sessions dict
    ```python
    class BSCWorkflow:
        def __init__(self):
            self._onboarding_sessions: dict[str, dict[str, Any]] = {}
        
        def handler(self, state):
            user_id = state.user_id
            # Load session
            session = self._onboarding_sessions.get(user_id, {})
            # Process...
            # Save session
            self._onboarding_sessions[user_id] = updated_session
            # Cleanup (se completo)
            if is_complete:
                del self._onboarding_sessions[user_id]
    ```
*   **ROI**: 20-30 min economizados (pattern reutilizÃ¡vel)

**11. Fixtures Pydantic com ID customizado**:
*   **SEMPRE** criar profile inline quando teste precisa `client_id` especÃ­fico
*   **Exemplo validado (2025-10-16)**: Fixture `client_id='fixture'`, teste esperava `'test_005'` â†’ assertion falhou
*   **Template**:
    ```python
    test_profile = ClientProfile(
        client_id="test_cliente_specific_id",  # Match user_id do teste
        company=valid_client_profile.company,  # Reutilizar outros campos
        context=valid_client_profile.context,
        # ... demais campos do fixture original
    )
    ```
*   **ROI**: 8-12 min economizados

**12. Teste de regressÃ£o crÃ­tico OBRIGATÃ“RIO**:
*   **SEMPRE** incluir 1 teste validando que funcionalidade existente NÃƒO quebrou
*   **Exemplo validado (2025-10-16)**: `test_rag_workflow_cliente_existente_nao_quebrado`
    *   Validou que cliente existente (phase=DISCOVERY) usa RAG tradicional
    *   Routing correto, workflow completo, zero breaking changes
*   **Template**:
    ```python
    def test_existing_functionality_not_broken():
        """CRÃTICO: Validar que funcionalidade X nÃ£o quebrou com nova feature Y.
        
        Este teste previne REGRESSÃƒO!
        """
        # Setup: Cliente/estado existente (nÃ£o novo)
        mock_existing_state()
        
        # Action: Executar workflow tradicional
        result = workflow.run_traditional_flow(...)
        
        # Assert: Comportamento mantido
        assert traditional_method.called
        assert not new_feature_method.called  # Nova feature NÃƒO interferiu
    ```
*   **ROI**: CrÃ­tico (previne breaking changes, economiza horas de rollback)

**13. Circular Imports Resolution (Validado FASE 2.7 - Out/2025)**
*   **SEMPRE** usar pattern oficial Python (PEP 484 + PEP 563) para resolver circular imports
*   **Exemplo validado (2025-10-16)**: Circular import entre client_profile_agent, onboarding_agent e workflow
*   **Pattern**:
    ```python
    # arquivo.py
    from __future__ import annotations  # PEP 563: Postponed annotations
    
    from typing import TYPE_CHECKING
    
    # TYPE_CHECKING = True durante type checking (mypy/pyright)
    # TYPE_CHECKING = False em runtime (evita circular import!)
    if TYPE_CHECKING:
        from outro_modulo import OutraClasse
    
    class MinhaClasse:
        def metodo(self, param: OutraClasse):  # Type hint funciona!
            # Import local em runtime quando necessÃ¡rio
            from outro_modulo import OutraClasse
            ...
    ```
*   **ROI**: 40-60 min economizados vs tentativa e erro manual
*   **LiÃ§Ã£o Detalhada**: `docs/lessons/lesson-discovery-state-circular-import-2025-10-16.md`

**14. Regression Prevention Strategy (Validado FASE 2.10 - Out/2025)**
*   **SEMPRE** incluir smoke tests (5-10 min por etapa) e regression suite semanal (1h por semana) para detectar regressÃµes em schemas core e cÃ³digo. Contract Testing para mudanÃ§as em schemas Pydantic.
*   **LiÃ§Ã£o Detalhada**: `docs/lessons/lesson-regression-prevention-methodology-2025-10-17.md`

**15. Pytest SEMPRE --tb=long SEM filtros (Validado FASE 2.10 - Out/2025)**
*   **SEMPRE** rodar testes com traceback completo e SEM filtros PowerShell para diagnosticar e evitar reexecuÃ§Ãµes.
*   **ROI**: 50% reduÃ§Ã£o tempo debugging, zero reexecuÃ§Ãµes desperdiÃ§adas.
*   **MemÃ³ria**: [[memory:10012853]] - Pytest SEMPRE --tb=long SEM filtros (economia 50% tempo debugging)

**16. Settings Singleton Pattern [[memory:10020824]]**
*   `config.settings.Settings` Ã© singleton; NUNCA recriar durante execuÃ§Ã£o.
*   **Por quÃª**: Pydantic precedÃªncia quando `_env_file` explÃ­cito: .env > env vars. Testes monkeypatch quebram.
*   **Exemplo ANTI-PATTERN**:
    ```python
    def validate_config():
        settings = Settings(_env_file=".env")  # Nova instÃ¢ncia, ignora monkeypatch!
    ```
*    **Exemplo CORRETO**:
    ```python
    from config.settings import settings  # Import singleton global

    def validate_config():
        current_settings = settings  # Usa global, respeita env vars
    ```
*   **ROI**: Previne falhas testes config validaÃ§Ã£o (2 testes corrigidos SessÃ£o 14)

Regarding `.cursorignore` files:

*   Cursor IDE uses `.cursorignore` files to control which files Cursor can access. This is for security and performance. This is for security and performance.
*   `.env` files are ignored by default.
*   To unignore a file, place an exclamation mark `!` in front of the ignore glob pattern in the `.cursorignore` file. For example: `!.env`.
*   You can edit the global ignore list in Cursor's settings. Go to `File > Preferences > VS code settings` and search for "Global Cursor Ignore List". You can remove patterns from the list there.
*   If you don't have a `.cursorignore` file, but `.env` files are still ignored, check the global ignore list.
*   Global cursorignore negations do not override `.gitignore` rules unless specific syntax is used.

### How to Liberate .env from the Global Cursor Ignore

Based on collected information, Cursor ignores `.env` files by default through global configuration. Here are three ways to liberate the file:

#### Method 1: Modify Global Ignore List (Recommended)

1.  **Open Cursor Settings:**
    *   Press `Ctrl + ,` (Windows) or `Cmd + ,` (Mac)
    *   Or go to: `File > Preferences > Settings`
2.  **Search for "Global Cursor Ignore":**
    *   Type in the search bar: `cursor ignore`
    *   Locate: **"Cursor > General: Global Cursor Ignore List"**
3.  **Remove or Comment the `.env` Entry:**
    *   You will see a list with patterns like:

    ```
    **/node_modules/**
    **/.git/**
    **/.env
    ```
    *   **Delete** the line `**/.env` or patterns related to `.env*`
    *   Click **"OK"** or save the settings.

#### Method 2: Use `.cursorignore` to "Unignore" (Local Override)

Create or edit the `.cursorignore` file in the **root of your project**:

```bash
# .cursorignore

# Unignore .env files (overrides the global ignore)
!.env
!.env.local
!.env.development

# You can also be more specific
!**/.env
```

**Important:** The `!` (exclamation) prefix **reverses** the ignore, allowing the file.

#### Method 3: Via Cursor Interface (Quick Shortcut)

1.  **Access Indexing Settings:**
    *   Go to: `Settings > Cursor > Indexing and Docs`
    *   Or search for: `cursor indexing`
2.  **Edit .cursorignore:**
    *   Click **"Edit .cursorignore"**
    *   Add the line: `!.env`
3.  **Reload the Index:**
    *   Press `Ctrl + Shift + P` (Windows) or `Cmd + Shift + P` (Mac)
    *   Type: `Cursor: Reindex Codebase`
    *   Execute the command

**IMPORTANT: Security Considerations**

Brightdata's research revealed important community discussions:

> **"Cursor ignores env files by default. Although risky, you can remove env files from the ignore list..."**

**Why does Cursor ignore `.env` by default?**

1.  **Credential Protection:** `.env` files contain API keys, passwords, and sensitive tokens.
2.  **Leakage Prevention:** Prevents information from being inadvertently sent to AI servers.
3.  **Context Security:** Prevents information from being inadvertently sent to AI servers.
4.  **Context Security:** Prevents credentials from appearing in chat/completions context.

**If you REALLY need to liberate `.env`:**

âœ… **Best Practice:**

*   Use `.env.example` or `.env.template` with dummy values.
*   Liberate **only** these template files in the ignore.
*   Keep the real `.env` ignored.

âŒ **Avoid:**

*   Liberating `.env` in public/shared projects.
*   Exposing real credentials in the AI context.
*   Removing protection in repositories with multiple collaborators.

**Test if it Worked**

1.  **Check the File Icon:**

    *   In the Cursor Explorer, ignored files show a ðŸš« icon.
    *   After liberating, the icon should disappear.
2.  **Test in Chat:**

    *   Open Cursor Chat.
    *   Type: `@.env` (mention the file).
    *   If it works, the file has been successfully liberated.
3.  **Verify Indexing:**

    *   `Ctrl + P` â†’ Type `.env`
    *   The file should appear in the results.

**Complete Example: `.cursorignore`**

```bash
# .cursorignore - Complete Example

# Keep ignored (security)
**/.env
**/.env.local
**/.env.production

# Liberate templates (safe)
!.env.example
!.env.template

# Other useful ignores
**/node_modules/**
**/.git/**
**/dist/**
**/build/**
**/__pycache/**
**/.pytest_cache/**
**/.venv/**
**/venv/**
```

**Sources (2025)**

*   [Cursor Docs - Ignore Files](https://cursor.com/docs/context/ignore/files)
*   [Cursor Forum - You can unignore files in .cursorignore](https://forum.cursor.com/t/you-can-unignore-files-in-cursorignore/38074)
*   [GitHub Issue #3101 - .env files ignored by default](https://github.com/cursor/cursor/issues/3101)
*   [Reddit r/cursor - How to disable .cursorignore from .cursorignore](https://www.reddit.com/r/cursor/comments/1ki08ww/)

### Language Detection Improvements

When the language detector in `src/rag/query_translator.py` is unable to determine the language of a query, it defaults to PT-BR. To improve language detection accuracy:

*   The `_detect_language` function has been enhanced with a regular expression to identify Portuguese suffixes (Ã§Ã£o, Ãµes, Ã¡rio, Ã¡rios, eira, eiras, eiro, eiros).
*   Word boundaries are used in keyword searches to prevent substring matches (e.g., "financial" in "financeiros").
*   The logging message has been updated to provide more context when the language is ambiguous.
*   Expand the list of keywords to include common BSC terms to improve language detection for technical queries.
*   When no keywords are detected, the system defaults to PT-BR, assuming a Brazilian context.

#### Code Snippets:

*   **Detecting Portuguese Suffixes:**

    ```python
    has_pt_suffixes = bool(re.search(r'\b\w*(Ã§Ã£o|Ãµes|Ã¡rio|Ã¡rios|eira|eiras|eiro|eiros)\b', text_lower))
    ```

*   **Keyword Search with Word Boundaries:**

    ```python
    pt_count = sum(1 for kw in pt_keywords if re.search(r'\b' + re.escape(kw) + r'\b', text_lower))
    en_count = sum(1 for kw in pt_keywords if re.search(r'\b' + re.escape(kw) + r'\b', text_lower))
    ```

### Dependency Management

*   When updating dependencies, especially `ruff`, ensure the version specified in `requirements.txt` is compatible with the project's other dependencies. Aim to use the latest stable version, but specify a version range to allow for minor updates without breaking changes. For example: `ruff>=0.7.0,<1.0.0`.
*   After updating dependencies in `requirements.txt`, run `pip install --upgrade -r requirements.txt` to update the environment.
*   When adding `mem0ai` ensure it is added in the Utilities section

### Pydantic Version Handling

*   When working with LangChain projects, be aware of Pydantic version compatibility. LangChain v0.3+ uses Pydantic V2 internally and recommends migrating imports from `langchain_core.pydantic_v1` to `pydantic` directly.
*   Avoid using the `pydantic.v1` compatibility namespace; import directly from Pydantic V2.
*   When using `BaseSettings` from `pydantic_settings`, use `SettingsConfigDict` instead of `ConfigDict` for configuration.
*   **Pydantic Config Migration**: Replace `class Config:` with `model_config = ConfigDict(...)` in Pydantic models to avoid deprecation warnings.

### New Rule: Python Circular Imports Resolution

When encountering circular import errors in Python, especially when using type hints, adhere to the following best practices:

- **Use `TYPE_CHECKING` for Conditional Imports**: Import modules or classes conditionally using the `typing.TYPE_CHECKING` flag. This ensures that the imports are only used during type-checking and not at runtime, which prevents circular import errors.
- **Leverage Lazy Imports**: Implement lazy imports within functions or methods. This defers the import statement until the function or method is called, avoiding circular dependencies during module loading.
- **Employ Forward References**: Use forward references as string literals for type hints. This allows you to refer to classes that are not yet defined. However, this approach should be combined with `from __future__ import annotations` for cleaner code.
- **Ensure Code Layering**: Refactor the code to ensure that the circular dependencies are not a result of poorly layered architecture. Consider using abstract classes or interfaces to define dependencies.
- **Apply Best Practices**: Follow community-endorsed best practices for circular import resolution.

### Rclone OneDrive Configuration and Usage

*   When using rclone with OneDrive, be aware of potential throttling issues, especially when transferring large files. To mitigate this, use the `--tpslimit` flag to limit transactions per second and the `--bwlimit` flag to limit bandwidth usage.
*   When encountering throttling errors, reduce the transfer rate or use rclone's built-in retry mechanisms.

### Architecture Reference Docs (FASE 3 - Out/2025)

When working on consulting code (agents, workflow, diagnostic tools):

**Consult `docs/architecture/` BEFORE reading source code:**

- **DATA_FLOW_DIAGRAMS.md**: Data flows (ClientProfile lifecycle, Diagnostic workflow, State transitions) - 5 Mermaid diagrams
- **API_CONTRACTS.md**: API contracts (signatures, parameters, exceptions, schemas) - 8 agents documented

**ROI**: ~1h saved per task (consult docs 1-2 min vs reading code 10-15 min)

**When to consult**:
- Implementing feature that interacts with existing agents
- Calling methods from other agents (needs exact signature)
- Debugging data flows or state transitions
- Creating tests (needs to know return types and exceptions)

*   When encountering "Should docs/DOCS_INDEX.md be transformed into a rule always applied, to prevent the agent from not consulting it?":

    *   **NO**: `docs/DOCS_INDEX.md` is a reference document for looking up documentation and is not needed for every task.
    *   Instead of making DOCS_INDEX.md an always applied rule, create **MINI-INDEX + MINI-PROGRESS** in `rag-bsc-core.mdc`. This saves tokens and provides a better ROI.
    *   Update rag-bsc-core.mdc with :
        *   **MINI-INDEX (Docs Essenciais - Top 10):**
            ```markdown
            ## ðŸ“š DocumentaÃ§Ã£o Essencial (Top 10)

            **SEMPRE consulte docs/DOCS_INDEX.md para catÃ¡logo completo (46 docs)**

            ### Arquitetura (4 docs crÃ­ticos)
            - `docs/ARCHITECTURE.md` - Overview arquitetural
            - `docs/LANGGRAPH_WORKFLOW.md` - Workflow LangGraph
            - `docs/architecture/API_CONTRACTS.md` - Contratos API 8 agentes (1200+ linhas)
            - `docs/architecture/DATA_FLOW_DIAGRAMS.md` - 5 diagramas Mermaid

            ### ImplementaÃ§Ã£o (3 docs crÃ­ticos)
            - `docs/TUTORIAL.md` - Guia completo de uso
            - `docs/TESTING_GUIDE.md` - EstratÃ©gias de teste
            - `docs/QUICKSTART.md` - Setup rÃ¡pido

            ### Techniques RAG (3 docs crÃ­ticos)
            - `docs/techniques/QUERY_DECOMPOSITION.md` - TECH-001
            - `docs/techniques/ADAPTIVE_RERANKING.md` - TECH-002
            - `docs/techniques/ROUTER.md` - TECH-003

            **Quando usar:**
            - Implementando features â†’ Consulte API_CONTRACTS + DATA_FLOW_DIAGRAMS
            - Escrevendo testes â†’ Consulte TESTING_GUIDE
            - Debugando fluxos â†’ Consulte DATA_FLOW_DIAGRAMS + LANGGRAPH_WORKFLOW
            - Implementando RAG â†’ Consulte docs/techniques/[TECHNIQUE].md
            ```
        *   **MINI-PROGRESS (Estado Atual do Projeto):**
            ```markdown
            ## ðŸ“Š Estado Atual do Projeto

            **SEMPRE consulte .cursor/progress/consulting-progress.md para histÃ³rico completo**

            ### Status Geral
            - **Fase Atual**: FASE 3 - Diagnostic Tools
            - **Progresso Geral**: 40% (20/50 tarefas)
            - **Progresso FASE 3**: 14% (2/14 tarefas - prep completa)
            - **Ãšltima AtualizaÃ§Ã£o**: 2025-10-19 (SessÃ£o 15)

            ### Tarefas Recentes (Ãšltimas 3)
            - âœ… **3.0.1** Data Flow Diagrams (COMPLETO - 2025-10-19)
              - EntregÃ¡vel: docs/architecture/DATA_FLOW_DIAGRAMS.md (5 diagramas)
            - âœ… **3.0.2** API Contracts (COMPLETO - 2025-10-19)
              - EntregÃ¡vel: docs/architecture/API_CONTRACTS.md (1200+ linhas)
            - âœ… **FASE 3 PREP** 100% completa, ROI ~7h economizadas

            ### PrÃ³xima Tarefa
            - ðŸŽ¯ **3.1** SWOT Analysis Tool (2-3h estimado)
              - DependÃªncias: API_CONTRACTS.md, DATA_FLOW_DIAGRAMS.md (âœ… satisfeitas)
              - Milestone: Primeira tool consultiva integrada com DiagnosticAgent
              - Status: DESBLOQUEADA e pronta para iniciar

            **Workflow obrigatÃ³rio**: Seguir 7 steps do rag-bsc-core.mdc antes de implementar
            ```
*   **YES**: Add a pointer in derived-cursor-rules.mdc to the existence of architecture reference documents. High visibility, low overhead.

*   **YES**: Add cross-references from `docs/ARCHITECTURE.md` to the data flow diagrams and API contracts.